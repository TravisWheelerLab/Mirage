#!/usr/bin/env perl
#
# MultiMSA.pl - Alex Nord - 2016
#
# ABOUT: In the mirage pipeline, this script is used to convert the exon-
#        aware hits produced by 'Quilter' into intra-species gene-family
#        MSAs.  It does this by scanning the nucleotide positions for each
#        hit within a gene family and inserting the corresponding (character
#        and sequence name) pair into a hash.  The keys to this hash, when
#        sorted, represent the columns of the hash.  A little extra work is
#        used to track splice sites.
#
use warnings;
use strict;
use POSIX;
use Cwd;

if (@ARGV < 2) { die "\n  USAGE:  perl  MultiMSA.pl  <Quilter output>  <Protein database>  [Opt.s]\n\n"; }

my ($i,$j,$k);

# Marks the ends of exons
my $specialChar = '*';

my $FinalMisses = 'MultiMSA.misses.out';
my $printConsensus = 0;
my $verbose  = 0;
my $specific = 0;
my $outputfolder = 'multilignments';
my $CPUs = 2;
my $canonical_species;

$i = 2;
while ($i < @ARGV) {
    if ($ARGV[$i] eq '-species') {
	$i++;
	$specific = $ARGV[$i];
    } elsif ($ARGV[$i] eq '-folder') {
	$i++;
	$outputfolder = $ARGV[$i];
    } elsif ($ARGV[$i] eq '-misses') {
	$i++;
	$FinalMisses = $ARGV[$i];
    } elsif ($ARGV[$i] eq '-v') {
	$verbose = 1;
    } elsif ($ARGV[$i] eq '-n') {
	$i++;
	$CPUs = int($ARGV[$i]);
	if ($CPUs <= 0) {
	    print "\n  Unsupported number of CPUs requested ($CPUs)\n";
	    print "  Reverting to default (2)\n\n";
	    $CPUs = 2;
	}
    } else {
	print "\n  Unrecognized option '$ARGV[$i]' ignored\n\n";
    }
    $i++;
}

my %Hits;
my %Nums;

if (-e $outputfolder) {
    $i = 2;
    while (-e $outputfolder.'_'.$i) {
	$i++;
    }
    $outputfolder = $outputfolder.'_'.$i;
}
system("mkdir $outputfolder");

open(my $infile,'<',$ARGV[0]) || die "\n  Failed to open input file '$ARGV[0]'\n\n";
while (!eof($infile)) {

    my $line = <$infile>;

    if ($line =~ /Isoform ID/) {

	my $ID_line       = $line;
	my $chr_name_line = <$infile>;
	my $pos_line      = <$infile>;
    
	# (1.) Strip down ID line into components 
	$ID_line =~ s/\r|\n//g;
	if (!($ID_line =~ /Isoform ID \: ([^\|]+)\|([^\|]+)\|([^\|]+)\|([^\|]+)/)) {
	    die "\n  ERROR:  Unexpected ID line:  $ID_line\n\n";
	}
	
	# NOTE:  This isn't guaranteed to work if Phosophosite switches out from 'GN:'
	my $db_entry  = 'GN:'.$1.'|'.$2.'|'.$3.'|'.$4;
	my $orig_gene = $1;
	my $gene      = uc($orig_gene);
	my $isoform   = $2;
	my $species   = $3;
	my $id_num    = $4;
	
	# Record the species
	$canonical_species = lc($3) if (!$canonical_species);
	
	# (2.) Rip out chromosome name
	$chr_name_line =~ s/\n|\r//g;
	if (!($chr_name_line =~ /Chromosome \: ([\w\-\,\.\/\(\)\'\[\]]+)/)) {
	    die "\n  ERROR:  Unexpected Chromosome line:  $chr_name_line\n\n";
	}
	my $chr_name = $1;
	
	# (3.) Rip out how we matched to this chromosome
	$pos_line =~ s/\n|\r//g;
	if (!($pos_line =~ /Match Pos\.s: (.*+)/)) {
	    die "\n  ERROR:  Unexpected Match Pos.s line:  $pos_line\n\n";
	}
	$pos_line = $1;
	
	# Stuff our new entry down the chimney
	my $hash_entry = $chr_name.'#'.$db_entry.'#'.$pos_line;
	if ($Hits{$gene}) {
	    $hash_entry = $Hits{$gene}.'&'.$hash_entry;
	    $Nums{$gene}++;
	} else {
	    $Nums{$gene}=1;
	}
	$Hits{$gene} = $hash_entry;
	
    }
    
}
close($infile);


# First progress message
my $progmsg;
if ($canonical_species) {
    $progmsg = '  MultiMSA.pl: Preparing to generate MSAs for '.$canonical_species;
} else {
    $progmsg = '  MultiMSA.pl: Preparing to generate MSAs';
}
while (length($progmsg) < 63) { $progmsg = $progmsg.' '; }
print "$progmsg\r" if (!$verbose);


# Naming convention for progress file
my $progressbase = 'MultiMSA.thread_progress.';


# We'll be breaking up the dataset based on gene names
my @AllGeneNames = sort keys %Hits;
my $TotNumGenes  = @AllGeneNames;
exit(0) if (!$TotNumGenes);
if ($TotNumGenes < $CPUs) { $CPUs = $TotNumGenes; }
my $portion;
if ($CPUs) { $portion = $TotNumGenes / $CPUs; }
else       { exit(0);                         } # decline gracefully


# Split into the requested number of (default 2) processes
my $processes = 1;
my $ThreadID  = 0; # In case we only have one process
my $pid;
while ($processes < $CPUs) {
    
    # Create new thread
    if ( $pid = fork ) {
	# Bail if we fail (nice rhyme!)
	if (not defined $pid) { die "\n\tFork failed\n\n"; }    
	# Giving the 'master' thread an ID of '0'
        $ThreadID = 0;
    } else {
        $ThreadID = $processes;
        last;
    }

    $processes++;

}


# Status printing stuff
my $progtime = time();
my $progfilename = $progressbase.$ThreadID;
my $num_complete = 0;


# Open up the file for writing misses (i.e., multi-chromosome
# hitting gene families) to.
# These files will all get appended into the same missfile
# generated by Quilter
my $missbase = 'MultiMSA.misses.';
my $missfilename = $missbase.$ThreadID;
open(my $missfile,'>',$missfilename) ||  die "\n  ERROR:  Failed to open file '$missfilename'\n\n";


# Now we can generate our MSAs (sorted for progress vis.)
my $startpoint = $ThreadID * $portion;
my $endpoint   = ($ThreadID+1) * $portion;
if ($ThreadID == $CPUs-1) { $endpoint = $TotNumGenes; }
foreach my $genename ($startpoint..$endpoint-1) {
    
    # Sorry about the awkward naming -- delayed parallelization
    my $gene = $AllGeneNames[$genename];
    print "  $gene\n" if ($verbose);
    
    my $outfilename = $outputfolder.'/'.$gene;
    if ($specific) {
	$outfilename = $outfilename.'_'.$specific;
    }
    $outfilename = $outfilename.'.afa';

    open(my $outfile,'>',$outfilename);

    my $numhits = $Nums{$gene};
    
    my $ChrName;
    my $revcomp;
    my @IsoNames;
    my @Species;
    my @DBEntries;
    my @PosStrings;
    my @ProteinSeqs;
    my @IsoIDs;

    my ($curr_chr,$NuclStart,$NuclEnd);
    my $hash_entry = $Hits{$gene};
    my @each_entry = split('&',$hash_entry);

    my $i = 0;
    my $chr_hits = 0;
    foreach $i (0..$numhits-1) {

	my $alt_chr = 0;
	
	my @this_entry  = split('#',$each_entry[$i]);
	$ChrName        = $this_entry[0];

	# Verifying that these genes all hit to the same chromosome
	if ($i == 0) { 

	    $PosStrings[$chr_hits] = $this_entry[2];
	    $DBEntries[$chr_hits]  = $this_entry[1];
	    $DBEntries[$chr_hits]  =~ /GN\:([^\|]+)\|([^\|]+)\|([^\|]+)\|([^\|]+)/;
	    $IsoNames[$chr_hits]   = $2;
	    $Species[$chr_hits]    = $3;
	    $IsoIDs[$chr_hits]     = $4;

	    $curr_chr = $ChrName;
	    if ($ChrName =~ /\[revcomp\]/) { $revcomp = 1; }
	    else                           { $revcomp = 0; }

	} elsif ($ChrName ne $curr_chr) {

	    # Write this guy out for future alignment using translated
	    # Needleman-Wunsch
	    print $missfile "$this_entry[1]\n";	    
	    $alt_chr = 1;

	} else {

	    $PosStrings[$chr_hits] = $this_entry[2];
	    $DBEntries[$chr_hits]  = $this_entry[1];
	    $DBEntries[$chr_hits]  =~ /GN\:([^\|]+)\|([^\|]+)\|([^\|]+)\|([^\|]+)/;
	    $IsoNames[$chr_hits]   = $2;
	    $Species[$chr_hits]    = $3;
	    $IsoIDs[$chr_hits]     = $4;
	    
	}

	# No need to keep playing around with this one
	next if ($alt_chr);

	# Get a hold of the proteins and record them as strings	
	my $eslsfetchCmd = "esl-sfetch $ARGV[1] \"$DBEntries[$i]\" \|";
	open(my $eslinput,$eslsfetchCmd) || die "\n  esl-sfetch failed to grab $DBEntries[$i] from $ARGV[1]\n\n";
	
	# Eat header line <- could be used for sanity check
	my $line = <$eslinput>;
	
	# Read in the protein sequence
	my $Protein = '';
	while ($line = <$eslinput>) {
	    $line =~ s/\n|\r//g;
	    $Protein = $Protein.$line;
	}
	close($eslinput);
	
	# Store the protein
	$ProteinSeqs[$chr_hits] = $Protein;
	$chr_hits++;	    
	
    }
    
    # It's worth remarking that even though we're hashing positions
    # we still need relative positioning, so it makes sense to use
    # ExonStarts and ExonEnds.

    # Now that we've got the overall min/max and each hit's string, we
    # can walk along, filling in an array for each of the strings.
    my %MSA;
    my %IntronTracker;
    my @TerminalNucl;
    foreach $i (0..$chr_hits-1) {

	# Converting the string of positions into individual codon centers
	my @Codons = split(',',$PosStrings[$i]);

	$ProteinSeqs[$i] =~ s/\s//g;
	my @Seq = split('',$ProteinSeqs[$i]);
	#print "@Seq\n";
		
	$j = 0; # How far along the series of codons we are
	$k = 0; # Position in Seq

	my $placer;
	my $prev_placer;
	my $prev_place;
	my $indel = 0;

	while ($j < @Codons) {

	    $placer = $Codons[$j];
	    
	    if ($placer =~ /\*/) {
		
		if ($revcomp) { $IntronTracker{$Codons[$j-1]-3} = 1 if ($Codons[$j-1] ne '*'); }
		else          { $IntronTracker{$Codons[$j-1]+3} = 1 if ($Codons[$j-1] ne '*'); }
		
	    } else {
		
		if ($prev_placer && $prev_placer !~ /\*/ 
		    && $prev_placer-$placer < 3 && $prev_placer-$placer > -3) {

		    $indel++;
		    if ($revcomp) {
			if ($MSA{$prev_place-$indel}) {
			    $MSA{$prev_place-$indel} = $MSA{$prev_place-$indel}.','.$i.':'.$Seq[$k];
			} else {
			    $MSA{$prev_place-$indel} = $i.':'.$Seq[$k];
			}
		    } else {
			if ($MSA{$prev_place+$indel}) {
			    $MSA{$prev_place+$indel} = $MSA{$prev_place+$indel}.','.$i.':'.$Seq[$k];
			} else {
			    $MSA{$prev_place+$indel} = $i.':'.$Seq[$k];
			}
		    }

		} else {
		    
		    $indel = 0;

		    # Standard placement, adding onto existing position
		    if ($MSA{$placer}) {
			$MSA{$placer} = $MSA{$placer}.','.$i.':'.$Seq[$k];
			$prev_place = $placer;
			
			# Special considerations for weird cases (like mouse OBSCN) where
			# we have regions that don't quite align
		    } elsif ($MSA{$placer+1} && $MSA{$placer+1} !~ /\,$i\:/) {
			$MSA{$placer+1} = $MSA{$placer+1}.','.$i.':'.$Seq[$k];
			$prev_place = $placer+1;
		    } elsif ($MSA{$placer-1} && $MSA{$placer-1} !~ /\,$i\:/) {
			$MSA{$placer-1} = $MSA{$placer-1}.','.$i.':'.$Seq[$k];
			$prev_place = $placer-1;
			
			# New placement
		    } else {		    
			$MSA{$placer} = $i.':'.$Seq[$k];
			$prev_place = $placer;
		    }
		    
		}
	    
		
		$k++;
		last if ($k >= @Seq);
		
	    }

	    $prev_placer = $placer;
	    
	    $j++;

	}
	
	$TerminalNucl[$i] = $Codons[@Codons-1];
	
    }

    # Used to check for mis-aligned positions
    my @FinalIntrons;
    my @CompressedStrings;
    my $compPos;

    # Generate a sorted list of our hash entries (positions in the table)
    my @PositionIndex = keys %MSA;
    my @IntronIndex   = keys %IntronTracker;
    if ($revcomp) { 
	@PositionIndex = sort {$b <=> $a} @PositionIndex; 
	@IntronIndex   = sort {$b <=> $a} @IntronIndex;
    } else { 
	@PositionIndex = sort {$a <=> $b} @PositionIndex; 
	@IntronIndex   = sort {$a <=> $b} @IntronIndex;
    }
    
    my $numIntrons = @IntronIndex;

    foreach $i (0..$chr_hits-1) {

	$compPos = 0;
	$IsoNames[$i] =~ s/\s//g;
	print $outfile ">GN:$gene|$IsoNames[$i]|$Species[$i]|$IsoIDs[$i]|Chromosome:$ChrName\n";

	$j = 0;
	my $NextIntron = 0;
	print $outfile "*";
	
	$j = 0;
	$k = 1;
	while ($j < @PositionIndex) {

	    # Patch this
	    if ($IntronIndex[$NextIntron] 
		&& (($revcomp && $PositionIndex[$j] <= $IntronIndex[$NextIntron])
		    || (!$revcomp && $PositionIndex[$j] >= $IntronIndex[$NextIntron]))) {
		
		push(@FinalIntrons,$compPos);
		print $outfile "*";
		
		while ($IntronIndex[$NextIntron] 
		       && (($revcomp && $PositionIndex[$j] <= $IntronIndex[$NextIntron])
			   || (!$revcomp && $PositionIndex[$j] >= $IntronIndex[$NextIntron]))) {
		    $NextIntron++;
		}

		$k++;
		if ($k == 50) {
		    print $outfile "\n";
		    $k = 0;
		}

	    }
	    
	    my $MSApos = $MSA{$PositionIndex[$j]};
		
	    if ($MSApos =~ /$i\:(\w)/) {
		$CompressedStrings[$i][$compPos] = $1;
		print $outfile "$1";
	    } else {
		$CompressedStrings[$i][$compPos] = "-";
		print $outfile "-";
	    }
	    
	    $compPos++;
	    $k++;
	    $j++;
	    
	    if ($k == 50) {
		print $outfile "\n";
		$k = 0;
	    }

	}

	print $outfile "*\n\n";
    }
    close($outfile);

    my @Consensus;
    my @Unanimous;
    
    foreach $j (0..$compPos-1) {
	
	my $letter = $CompressedStrings[0][$j];
	my $consString; 
	my %consLetters;
	if ($letter ne '-') {
	    $consString = $letter;
	    $consLetters{$letter} = 1;		
	}
	
	foreach $i (1..$chr_hits-1) {
	    
	    $letter = $CompressedStrings[$i][$j];
	    
	    next if ($letter eq '-');
	    
	    if (!$consLetters{$letter}) {
		$consLetters{$letter} = 1;
		my @Letters = sort keys %consLetters;
		if (@Letters > 1) {
		    $consString = '['.$Letters[0];		    
		    foreach $k (1..@Letters-1) {
			$consString = $consString.','.$Letters[$k];
		    }
		    $consString = $consString.']';
		} else {
		    $consString = $letter;
		}
	    } else {
		$consLetters{$letter}++;
	    }
	    
	}
	
	$Unanimous[$j] = $consString;
	
	my @Letters = sort keys %consLetters;
	$letter = $Letters[0];
	my $votes = $consLetters{$letter};
	foreach $k (1..@Letters-1) {
	    if ($consLetters{$Letters[$k]} > $votes) {
		$votes = $consLetters{$Letters[$k]};
		$letter = $Letters[$k];
	    }
	}
	$Consensus[$j] = $letter;
    }

    # Now that Consensus and Unanimous are fully filled-in, we can
    # look back through CompressedStrings for intron boundaries
    my $NextIntron = 0;
    my @FinalConsensusSeq;
    my @FinalUnanimousSeq;
    $FinalConsensusSeq[0] = $specialChar;
    $FinalUnanimousSeq[0] = $specialChar;
    my $dropPos = 1;
    foreach $j (0..$compPos-1) {
	
	
	if ($NextIntron < @FinalIntrons && $j >= $FinalIntrons[$NextIntron]) {		
	    $NextIntron++;
	    $FinalConsensusSeq[$dropPos] = $specialChar;
	    $FinalUnanimousSeq[$dropPos] = $specialChar;
	    $dropPos++;
	}
	$FinalConsensusSeq[$dropPos] = $Consensus[$j];
	$FinalUnanimousSeq[$dropPos] = $Unanimous[$j];
	$dropPos++;
	
    }
    
    # Special final "intron" start
    $FinalConsensusSeq[$dropPos] = $specialChar;
    $FinalUnanimousSeq[$dropPos] = $specialChar;
    $dropPos++;
    
    
    # Let's record this and be done with it!
    $k = 0;
    my @disagreements;
    my $consfilename = $outfilename;
    $consfilename =~ s/\.afa/\_consensus\.afa/;
    open(my $consfile,'>',$consfilename) if ($printConsensus);
    print $consfile "> $gene|$outfilename|$ARGV[0]|compressed_msa\n" if ($printConsensus);
    foreach $j (0..$dropPos-1) {
	print $consfile "$FinalConsensusSeq[$j]" if ($printConsensus);
	$k++;
	if ($k == 50) {
	    print $consfile "\n" if ($printConsensus);
	    $k = 0;
	}
	if ($FinalConsensusSeq[$j] ne $FinalUnanimousSeq[$j]) {
	    push(@disagreements,$j);
	}		
    }
    print $consfile "\n" if ($printConsensus);
    close($consfile) if ($printConsensus);
    
    # If we had any disagreements let the user know
    if (@disagreements) {

	my $numdisagreements = @disagreements;
	my $disfilename = $outfilename;

	$disfilename =~ s/\.afa/\_ARFs/;
	print "  > WARNING: $numdisagreements positions did not reach unanimous consensus (see $disfilename)\n" if ($verbose);

	open(my $disfile,'>',$disfilename);
	print $disfile "$numdisagreements mismatched sites\n";
	print $disfile "$disagreements[0]-";
	foreach $j (1..$numdisagreements-1) {
	    if ($disagreements[$j] != $disagreements[$j-1]+1) {
		print $disfile "$disagreements[$j-1],$disagreements[$j]-";
	    }
	}
	print $disfile "$disagreements[$numdisagreements-1]\n";
	close($disfile);

    }


    # Status reporting stuff:
    if (!$verbose) {
	$num_complete++;
	if (time()-$progtime > 2) {
	    
	    if ($ThreadID) {
		open(my $progfile,'>',$progfilename);
		print $progfile "$num_complete\n";
		close($progfile);
		
	    } else {
		
		# Generate call to ProgressTimer
		my $progressCmd = './src/ProgressTimer.pl '.$progressbase.' '.$CPUs;
		$progressCmd = $progressCmd.' '.$num_complete.' |';
		
		# Make the call and read the results
		open(my $progfile,$progressCmd);
		my $overall_progress = readline($progfile);
		close($progfile);
		$overall_progress =~ s/\n|\r//g;
		
		# Pull together the message
		my $progmsg = '  MultiMSA.pl: '.$overall_progress.' gene families aligned ('.$canonical_species.')';
		while (length($progmsg) < 63) { $progmsg = $progmsg.' '; }
		print "$progmsg\r";
		
	    }
	    
	    # Set new prog timer
	    $progtime = time();
	    
	}
    }
}


# Close up individual missfiles
close($missfile);


# de-fork
if ($ThreadID) { exit(0); }
while (wait() != -1) {}


# Clean up progress files and concatenate all missfiles into 'FinalMisses'
for ($i = 0; $i < $CPUs; $i++) {

    $progfilename = $progressbase.$i;
    if (-e $progfilename && system("rm $progfilename")) { die "\n  Failed to remove file $progfilename\n\n"; }

    $missfilename = $missbase.$i;
    if (-e $missfilename) {
	system("cat $missfilename >> $FinalMisses");
	system("rm $missfilename");
    }
    
}


# Final report
$progmsg = '  MultiMSA.pl: '.$canonical_species.' complete';
while (length($progmsg) < 63) { $progmsg = $progmsg.' '; }
print "$progmsg\r" if (!$verbose);


# Mad phresh stylez 4 lyfe
1;


